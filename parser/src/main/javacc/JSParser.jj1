/**
 *
 * Copyright (C) 1996 Sun Microsystems Inc.
 *
 * Use of this file and the system it is part of is constrained by the
 * file COPYRIGHT in the root directory of this system.  You may, however,
 * make any modifications you wish to this file.
 *
 * Java files generated by running Jack on this file (or modified versions
 * of this file) may be used in exactly the same manner as Java files
 * generated from any grammar developed by you.
 *
 * Author: Sriram Sankar
 * Date: 6/11/96
 *
 * This file contains a Javascript grammar and actions that implement a front-end.
 *
 */
                                                         
/*options {
  LOOKAHEAD = 1;
  DEBUG = false;
  ERROR_REPORTING = true;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
}*/
options {
  STATIC = false;
  LOOKAHEAD = 1;
  JAVA_UNICODE_ESCAPE = true;
  UNICODE_INPUT = false;
}

PARSER_BEGIN(JSParser)

package roland.javascript;

import java.util.Vector;

public class JSParser {
}

PARSER_END(JSParser)


SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < ABSTRACT: "abstract" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DELETE: "delete" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < FUNCTION: "function" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < IN: "in" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRY: "try" >
| < TYPEOF: "typeof" >
| < VAR: "var">
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
| < WITH: "with" >
}

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL>
      | <HEX_LITERAL>
      | <OCTAL_LITERAL>
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?
      | "." (["0"-"9"])+ (<EXPONENT>)?
      | (["0"-"9"])+ (<EXPONENT>)?
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING_LITERAL:
        "\""
        (   (~["\"","\\","\n","\r"])
        | <ESCAPE_SEQUENCE>
        )*
        "\""
      | "'"
        (   (~["'","\\","\n","\r"])
        | <ESCAPE_SEQUENCE>
        )*
        "'"
  >
|
  < #ESCAPE_SEQUENCE:
      "\\"
        ( ["n","t","b","r","f","\\","'","\""]
        | ["0"-"7"] ( ["0"-"7"] )?
        | ["0"-"3"] ["0"-"7"] ["0"-"7"]
        | ["x", "X"] ["0"-"9","a"-"f","A"-"F"] ["0"-"9","a"-"f","A"-"F"]
        )
  >
|
  < BOOLEAN_LITERAL:
        "true"
      |
        "false"
  >
|
  < NULL_LITERAL:
      "null"
  >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff",
       "_",
       "$"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
}

TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < DOT: "." >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
| < RUNSIGNEDSHIFT: ">>>" >
| < SC_ORASSIGN: "||=" >
| < SC_ANDASSIGN: "&&=" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < BIT_ANDASSIGN: "&=" >
| < BIT_ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */
JSStatement Program() :
{
	JSCompoundStatement p = new JSCompoundStatement(new Token());
  JSStatement s;
}
{
  (
  	s=Element()
    														{
                                	p.add(s);
                                }
  )*
  <EOF>
  															{
                                	return p;
                                }
}

JSStatement Element() :
{
	JSStatement s = null;
  Token t;
  Token t2;
  Vector v = null;
}
{
	(
  	  t="function" t2=<IDENTIFIER> "(" ( v=ParameterList() )? ")" s=CompoundStatement()
    														{
                                	if( v == null) {
                                  	v = new Vector();
                                  }
                                  s = new JSFuncDeclStatement( t, t2.image, v, s);
                                }
  	|
    	s=Statement()
  )
  															{
                                	return s;
                                }
}

// Returns a Vector of strings, one for each identifier.
Vector ParameterList() :
{
	Token t;
	Vector v = new Vector();
}
{
  t=<IDENTIFIER>
  															{
                                	v.addElement(t.image);
                                }
  (
  	"," t=<IDENTIFIER>
    														{
                                	v.addElement(t.image);
                                }
  )*
  															{
                                	return v;
                                }
}

JSCompoundStatement CompoundStatement() :
{
	Token t;
	JSCompoundStatement stmts;
  JSStatement stmt;
}
{
  t="{"
  															{
                                	stmts = new JSCompoundStatement(t);
                                }
  (
  	stmt=Statement()
    														{
                                	stmts.add(stmt);
                                }
  )*
  "}"
                                {
                                  return stmts;
                                }
}

// The spec requires ";" after expressions, variables declarations, break,
//   continue and return. I've ignored that here.
JSStatement Statement() :
{
	Token t;
	JSStatement stmt;
  JSExpression e1=null;
  JSExpression e2=null;
  JSExpression e3=null;
  JSStatement s1=null;
  JSStatement s2=null;
}
{
	(
      t=";"
                                {
                                  stmt = new JSEmptyStatement(t);
                                }
    |
      t="if" e1=Condition() s1=Statement() ( "else" s2=Statement() )?
                                {
                                  stmt = new JSIfStatement(t, e1, s1, s2);
                                }
    |
      t="while" e1=Condition() s1=Statement()
                                {
                                  stmt = new JSWhileStatement( t, e1, s1);
                                }
    |
      LOOKAHEAD(3)
      t="for" "(" ";" ( e2=Expression() )? ";" ( e3=Expression() )? ")" s1=Statement()
                                {
                                  stmt = new JSForStatement( t, e1, e2, e3, s1);
                                }
    |
      LOOKAHEAD( "for" "(" VariablesOrExpression() ";" )
      t="for" "(" e1=VariablesOrExpression() ";" ( e2=Expression() )? ";" ( e3=Expression() )? ")" s1=Statement()
                                {
                                  stmt = new JSForStatement( t, e1, e2, e3, s1);
                                }
    |
      t="for" "(" VariablesOrExpression() "in" Expression() ")" Statement()
                                {
                                  // ### still to do
                                  stmt = null;
                                }
    |
      t="break"
                                {
                                  stmt = new JSBreakStatement(t);
                                }
    |
      t="continue"
                                {
                                  stmt = new JSContinueStatement(t);
                                }
    |
      t="with" "(" e1=Expression() ")" s1=Statement()
                                {
                                  // ### still to do
                                  stmt = null;
                                }
    |
      t="return" ( e1=Expression() )?
                                {
                                  stmt = new JSReturnStatement(t, e1);
                                }
    |
      stmt=CompoundStatement()
    |
      stmt=VariablesOrExpression()
  )
    														{
                                	return stmt;
                                }
}

JSExpression Condition() :
{
  JSExpression e = null;
}
{
  "(" e=Expression() ")"
                                {
                                  return e;
                                }
}

// ### Check up on the semantics of this - not sure whether it should be statement
//		or expression
JSExpression VariablesOrExpression() :
{
	Token t;
	JSExpression e = null;
  Vector v = null;
}
{
	(
      t="var" v=Variables()
      													{
                                	e = new JSVarDeclExpression(t, v);
                                }
    |
      e=Expression()
  )
                                {
                                  return e;
                                }
}

// Vector of JSVarDecl's
Vector Variables() :
{
	Vector v = new Vector();
  JSVarDecl d;
}
{
  d=Variable()
  															{
                                	v.addElement(d);
                                }
  (
  	"," d=Variable()
  															{
                                	v.addElement(d);
                                }
  )*
  															{
                                	return v;
                                }
}

JSVarDecl Variable() :
{
	Token t;
  JSExpression e = null;
}
{
  t=<IDENTIFIER> ( "=" e=AssignmentExpression() )?
                                {
                                  return new JSVarDecl(t, e);
                                }
}

JSExpression Expression() :
{
	Token t;
  JSExpression e = null;
  JSExpression e2;
}
{
  e=AssignmentExpression()
  (
  	t="," e2=AssignmentExpression()
    														{
                                	e = new JSBinaryExpression( t, e, e2);
                                }
  )*
                                {
                                  return e;
                                }
}

JSExpression AssignmentExpression() :
{
	Token t;
  JSExpression e = null;
  JSExpression e2;
}
{
  e=ConditionalExpression()
  (
  	( t="=" | t="&&=" | t="||=" | t="+=" | t="-=" | t="*=" | t="/=" | t="&=" | t="|=" | t="^=" | t="%=" | t="<<=" | t=">>=" | t=">>>=" )
    e2=ConditionalExpression()
    														{
                                	e = new JSBinaryExpression( t, e, e2);
                                }
  )*
                                {
                                  return e;
                                }
}

JSExpression ConditionalExpression() :
{
	Token t;
  JSExpression e = null;
  JSExpression e2;
  JSExpression e3;
}
{
  e=OrExpression()
  (
  	t="?" e2=AssignmentExpression() ":" e3=AssignmentExpression()
    														{
                                	e = new JSConditionalExpression( t, e, e2, e3);
                                }
  )?
                                {
                                  return e;
                                }
}

JSExpression OrExpression() :
{
	Token t;
  JSExpression e = null;
  JSExpression e2;
}
{
  e=AndExpression()
  (
  	t="||" e2=AndExpression()
    														{
                                	e = new JSBinaryExpression( t, e, e2);
                                }
  )*
                                {
                                  return e;
                                }
}

JSExpression AndExpression() :
{
	Token t;
  JSExpression e = null;
  JSExpression e2;
}
{
  e=BitwiseOrExpression()
  (
  	t="&&" e2=BitwiseOrExpression()
    														{
                                	e = new JSBinaryExpression( t, e, e2);
                                }
  )*
                                {
                                  return e;
                                }
}

JSExpression BitwiseOrExpression() :
{
	Token t;
  JSExpression e = null;
  JSExpression e2;
}
{
  e=BitwiseXorExpression()
  (
  	t="|" e2=BitwiseXorExpression()
    														{
                                	e = new JSBinaryExpression( t, e, e2);
                                }
  )*
                                {
                                  return e;
                                }
}

JSExpression BitwiseXorExpression() :
{
	Token t;
  JSExpression e = null;
  JSExpression e2;
}
{
  e=BitwiseAndExpression()
  (
  	t="^" e2=BitwiseAndExpression()
    														{
                                	e = new JSBinaryExpression( t, e, e2);
                                }
  )*
                                {
                                  return e;
                                }
}

JSExpression BitwiseAndExpression() :
{
	Token t;
  JSExpression e = null;
  JSExpression e2;
}
{
  e=EqualityExpression()
  (
  	t="&" e2=EqualityExpression()
    														{
                                	e = new JSBinaryExpression( t, e, e2);
                                }
  )*
                                {
                                  return e;
                                }
}

JSExpression EqualityExpression() :
{
	Token t;
  JSExpression e = null;
  JSExpression e2;
}
{
  e=RelationalExpression()
  (
  	( t="==" | t="!=" ) e2=RelationalExpression()
    														{
                                	e = new JSBinaryExpression( t, e, e2);
                                }
  )*
                                {
                                  return e;
                                }
}

JSExpression RelationalExpression() :
{
	Token t;
  JSExpression e = null;
  JSExpression e2;
}
{
  e=ShiftExpression()
  (
  	( t="<" | t=">" | t="<=" | t=">=" ) e2=ShiftExpression()
    														{
                                	e = new JSBinaryExpression( t, e, e2);
                                }
  )*
                                {
                                  return e;
                                }
}

JSExpression ShiftExpression() :
{
	Token t;
  JSExpression e = null;
  JSExpression e2;
}
{
  e=AdditiveExpression()
  (
  	( t="<<" | t=">>" | t=">>>" ) e2=AdditiveExpression()
    														{
                                	e = new JSBinaryExpression( t, e, e2);
                                }
  )*
                                {
                                  return e;
                                }
}

JSExpression AdditiveExpression() :
{
	Token t;
  JSExpression e = null;
  JSExpression e2;
}
{
  e=MultiplicativeExpression()
  (
  	( t="+" | t="-" ) e2=MultiplicativeExpression()
    														{
                                	e = new JSBinaryExpression( t, e, e2);
                                }
  )*
                                {
                                  return e;
                                }
}

JSExpression MultiplicativeExpression() :
{
	Token t;
  JSExpression e = null;
  JSExpression e2;
}
{
  e=UnaryExpression()
  (
  	( t="*" | t="/" | t="%" ) e2=UnaryExpression()
    														{
                                	e = new JSBinaryExpression( t, e, e2);
                                }
  )*
                                {
                                  return e;
                                }
}

JSExpression UnaryExpression() :
{
  Token t = null;
  JSExpression e = null;
  boolean prefix = true;
}
{
  (
    ( t="!" | t="~" ) e=UnaryExpression()
  |
    t="-" e=UnaryExpression()
  |
    ( t="++" | t="--" ) e=MemberExpression()
  |
    e=MemberExpression() ( ( t="++" | t="--" ) {prefix = false;} )?
  |
    t="new" /*e=*/Constructor()
  |
    t="delete" e=MemberExpression()
  )
                                {
                                  if(t != null) {
                                    return new JSUnaryExpression(t, e, prefix);
                                  }

                                  return e;
                                }
}

void Constructor() :
{}
{
    "this" "." ConstructorCall()
  |
    ConstructorCall()
}

void ConstructorCall() :
{}
{
    LOOKAHEAD(2)
    <IDENTIFIER> "(" ( ArgumentList() )? ")"
  |
    LOOKAHEAD(2)
    <IDENTIFIER> "." ConstructorCall()
  |
    <IDENTIFIER>
}

// Departs from the grammar in the standard, since this works in all browsers
JSExpression MemberExpression() :
{
	Token t;
  JSExpression e;
  JSExpression e2;
  Vector v=null;	// Vector of JSExpression's
}
{
  e=PrimaryExpression()
  (
  		// ###Check up on this - I didn't know that you could have x.this.etc.
      t="." e2=PrimaryExpression()
      													{
                                	e = new JSBinaryExpression( t, e, e2);
                                }
    |
      t="[" e2=Expression() "]"
      													{
                                	e = new JSBinaryExpression( t, e, e2);
                                }
    |
      t="(" ( v=ArgumentList() )? ")"
      													{
                                	if( v == null) {
                                  	v = new Vector();
                                  }
                                  e = new JSFunctionExpression( t, e, v);
                                }
  )*
                                {
                                  return e;
                                }
}

// Vector of JSExpressions
Vector ArgumentList() :
{
	Vector v = new Vector();
  JSExpression e;
}
{
  e=AssignmentExpression()
  															{
                                	v.addElement(e);
                                }
  (
  	"," e=AssignmentExpression()
  															{
                                	v.addElement(e);
                                }
  )*
  															{
                                	return v;
                                }
}

JSExpression PrimaryExpression() :
{
  JSExpression e = null;
  Token t = null;
  boolean islit = true;
}
{
  (
    "(" e=Expression() ")"
    														{
                                	islit = false;
                                }
  |
    t=<IDENTIFIER>
    														{
                                	islit = false;
                                  e = new JSIdentifier(t);
                                }
  |
    t=<INTEGER_LITERAL>
  |
    t=<FLOATING_POINT_LITERAL>
  |
    t=<STRING_LITERAL>
  |
    t=<BOOLEAN_LITERAL>
  |
    t=<NULL_LITERAL>
  |
    t="this"
    														{
                                	islit = false;
                                  e = new JSThis(t);
                                }
  )
                                {
                                	if( islit) {
                                  	e = new JSLiteral(t);
                                  }
                                  return e;
                                }
}
